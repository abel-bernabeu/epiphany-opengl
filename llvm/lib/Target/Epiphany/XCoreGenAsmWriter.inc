//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void XCoreAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    399U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    392U,	// BUNDLE
    536870981U,	// ADD_2rus
    536870981U,	// ADD_3r
    1090519051U,	// ADJCALLSTACKDOWN
    1107296267U,	// ADJCALLSTACKUP
    542114069U,	// ANDNOT_2r
    536870986U,	// AND_3r
    536871068U,	// ASHR_l2rus
    536871068U,	// ASHR_l3r
    587202870U,	// BAU_1r
    537919845U,	// BITREV_l2r
    587202612U,	// BLA_1r
    587202669U,	// BL_lu10
    587202669U,	// BL_u10
    537919567U,	// BRBF_lru6
    537919567U,	// BRBF_ru6
    537919720U,	// BRBT_lru6
    537919720U,	// BRBT_ru6
    587202875U,	// BRBU_lu6
    587202875U,	// BRBU_u6
    537919567U,	// BRFF_lru6
    537919567U,	// BRFF_ru6
    537919720U,	// BRFT_lru6
    537919720U,	// BRFT_ru6
    587202875U,	// BRFU_lu6
    587202875U,	// BRFU_u6
    1686110540U,	// BR_JT
    1690304844U,	// BR_JT32
    537919836U,	// BYTEREV_l2r
    621806091U,	// CHKCT_2r
    621806091U,	// CHKCT_rus
    674U,	// CLRE_0R
    587202734U,	// CLRSR_branch_lu6
    587202734U,	// CLRSR_branch_u6
    587202734U,	// CLRSR_lu6
    587202734U,	// CLRSR_u6
    537919875U,	// CLZ_l2r
    537264169U,	// CRC8_l4r
    541327381U,	// CRC_l3r
    536871138U,	// DIVS_l3r
    536871254U,	// DIVU_l3r
    587202643U,	// ECALLF_1r
    587202824U,	// ECALLT_1r
    637534783U,	// EEU_1r
    654311548U,	// ENDIN_l2r
    587202698U,	// ENTSP_lu6
    587202698U,	// ENTSP_u6
    536871064U,	// EQ_2rus
    536871064U,	// EQ_3r
    587202705U,	// EXTSP_lu6
    587202705U,	// EXTSP_u6
    637534708U,	// FREER_1r
    650U,	// GETED_0R
    679U,	// GETET_0R
    662U,	// GETID_0R
    671088899U,	// GETPS_l2r
    537919676U,	// GETR_rus
    654311709U,	// GETST_2r
    654311643U,	// GETTS_2r
    654311660U,	// INCT_2r
    687866492U,	// INITCP_2r
    704643708U,	// INITDP_2r
    721420924U,	// INITLR_l2r
    738198140U,	// INITPC_2r
    754975356U,	// INITSP_2r
    654311586U,	// INSHR_2r
    654311696U,	// INT_2r
    654311551U,	// IN_2r
    537067588U,	// LADD_l5r
    538968258U,	// LD16S_3r
    538968368U,	// LD8U_3r
    540016668U,	// LDA16B_l3r
    538968092U,	// LDA16F_l3r
    587202561U,	// LDAP_lu10
    587202561U,	// LDAP_lu10_ba
    587202561U,	// LDAP_u10
    540017011U,	// LDAWB_l2rus
    540017011U,	// LDAWB_l3r
    2147484057U,	// LDAWCP_lu6
    2147484057U,	// LDAWCP_u6
    771752307U,	// LDAWDP_lru6
    771752307U,	// LDAWDP_ru6
    1325400075U,	// LDAWFI
    538968435U,	// LDAWF_l2rus
    538968435U,	// LDAWF_l3r
    805306739U,	// LDAWSP_lru6
    805306739U,	// LDAWSP_lru6_RRegs
    805306739U,	// LDAWSP_ru6
    805306739U,	// LDAWSP_ru6_RRegs
    537919551U,	// LDC_lru6
    537919551U,	// LDC_ru6
    537067885U,	// LDIV_l5r
    822083961U,	// LDWCP_lru6
    822083961U,	// LDWCP_ru6
    771752313U,	// LDWDP_lru6
    771752313U,	// LDWDP_ru6
    1375731723U,	// LDWFI
    805306745U,	// LDWSP_lru6
    805306745U,	// LDWSP_ru6
    538968441U,	// LDW_2rus
    538968441U,	// LDW_3r
    537100406U,	// LMUL_l6r
    536871126U,	// LSS_3r
    537067577U,	// LSUB_l5r
    536871249U,	// LSU_3r
    537395401U,	// MACCS_l4r
    537395519U,	// MACCU_l4r
    637534686U,	// MJOIN_1r
    537919590U,	// MKMSK_2r
    537919590U,	// MKMSK_rus
    637534631U,	// MSYNC_1r
    536871031U,	// MUL_l3r
    537919579U,	// NEG
    537919768U,	// NOT
    536871082U,	// OR_3r
    621806102U,	// OUTCT_2r
    621806102U,	// OUTCT_rus
    1699742207U,	// OUTSHR_2r
    621806124U,	// OUTT_2r
    621806134U,	// OUT_2r
    654311520U,	// PEEK_l2r
    536871120U,	// REMS_l3r
    536871238U,	// REMU_l3r
    587202691U,	// RETSP_lu6
    587202691U,	// RETSP_u6
    1392508939U,	// SELECT_CC
    621806034U,	// SETCLK_l2r
    621806014U,	// SETC_l2r
    621806014U,	// SETC_lru6
    621806014U,	// SETC_ru6
    621806024U,	// SETD_2r
    872415816U,	// SETEV_1r
    621806002U,	// SETPSC_l2r
    621806196U,	// SETPS_l2r
    621806113U,	// SETPT_2r
    621806184U,	// SETRDY_l2r
    587202572U,	// SETSP_1r
    587202741U,	// SETSR_branch_lu6
    587202741U,	// SETSR_branch_u6
    587202741U,	// SETSR_lu6
    587202741U,	// SETSR_u6
    621806173U,	// SETTW_l2r
    872415827U,	// SETV_1r
    542114084U,	// SEXT_2r
    542114084U,	// SEXT_rus
    536871025U,	// SHL_2rus
    536871025U,	// SHL_3r
    536871069U,	// SHR_2rus
    536871069U,	// SHR_3r
    644U,	// SSYNC_0r
    538968099U,	// ST16_l3r
    538968111U,	// ST8_l3r
    771752318U,	// STWDP_lru6
    771752318U,	// STWDP_ru6
    1426063371U,	// STWFI
    805306750U,	// STWSP_lru6
    805306750U,	// STWSP_ru6
    538968446U,	// STW_2rus
    538968446U,	// STW_3r
    536870970U,	// SUB_2rus
    536870970U,	// SUB_3r
    637534697U,	// SYNCR_1r
    654311666U,	// TESTCT_2r
    654311674U,	// TESTWCT_2r
    691U,	// WAITEU_0R
    536871081U,	// XOR_l3r
    542114090U,	// ZEXT_2r
    542114090U,	// ZEXT_rus
    0U
  };

  const char AsmStrs[] = {
  /* 0 */ 'l', 'd', 'a', 'p', 32, 'r', '1', '1', ',', 32, 0,
  /* 11 */ 's', 'e', 't', 32, 's', 'p', ',', 32, 0,
  /* 20 */ 'c', 'r', 'c', '3', '2', 32, 0,
  /* 27 */ 'l', 'd', 'a', '1', '6', 32, 0,
  /* 34 */ 's', 't', '1', '6', 32, 0,
  /* 40 */ 'c', 'r', 'c', '8', 32, 0,
  /* 46 */ 's', 't', '8', 32, 0,
  /* 51 */ 'b', 'l', 'a', 32, 0,
  /* 56 */ 'l', 's', 'u', 'b', 32, 0,
  /* 62 */ 'l', 'd', 'c', 32, 0,
  /* 67 */ 'l', 'a', 'd', 'd', 32, 0,
  /* 73 */ 'a', 'n', 'd', 32, 0,
  /* 78 */ 'b', 'f', 32, 0,
  /* 82 */ 'e', 'c', 'a', 'l', 'l', 'f', 32, 0,
  /* 90 */ 'n', 'e', 'g', 32, 0,
  /* 95 */ 'p', 'e', 'e', 'k', 32, 0,
  /* 101 */ 'm', 'k', 'm', 's', 'k', 32, 0,
  /* 108 */ 'b', 'l', 32, 0,
  /* 112 */ 's', 'h', 'l', 32, 0,
  /* 117 */ 'l', 'm', 'u', 'l', 32, 0,
  /* 123 */ 'e', 'n', 'd', 'i', 'n', 32, 0,
  /* 130 */ 'r', 'e', 't', 's', 'p', 32, 0,
  /* 137 */ 'e', 'n', 't', 's', 'p', 32, 0,
  /* 144 */ 'e', 'x', 't', 's', 'p', 32, 0,
  /* 151 */ 'e', 'q', 32, 0,
  /* 155 */ 'a', 's', 'h', 'r', 32, 0,
  /* 161 */ 'i', 'n', 's', 'h', 'r', 32, 0,
  /* 168 */ 'x', 'o', 'r', 32, 0,
  /* 173 */ 'c', 'l', 'r', 's', 'r', 32, 0,
  /* 180 */ 's', 'e', 't', 's', 'r', 32, 0,
  /* 187 */ 'g', 'e', 't', 'r', 32, 0,
  /* 193 */ 'l', 'd', '1', '6', 's', 32, 0,
  /* 200 */ 'm', 'a', 'c', 'c', 's', 32, 0,
  /* 207 */ 'r', 'e', 'm', 's', 32, 0,
  /* 213 */ 'l', 's', 's', 32, 0,
  /* 218 */ 'g', 'e', 't', 't', 's', 32, 0,
  /* 225 */ 'd', 'i', 'v', 's', 32, 0,
  /* 231 */ 'b', 't', 32, 0,
  /* 235 */ 'i', 'n', 'c', 't', 32, 0,
  /* 241 */ 't', 'e', 's', 't', 'c', 't', 32, 0,
  /* 249 */ 't', 'e', 's', 't', 'w', 'c', 't', 32, 0,
  /* 258 */ 'g', 'e', 't', 32, 0,
  /* 263 */ 'e', 'c', 'a', 'l', 'l', 't', 32, 0,
  /* 271 */ 'i', 'n', 't', 32, 0,
  /* 276 */ 'a', 'n', 'd', 'n', 'o', 't', 32, 0,
  /* 284 */ 'g', 'e', 't', 's', 't', 32, 0,
  /* 291 */ 's', 'e', 'x', 't', 32, 0,
  /* 297 */ 'z', 'e', 'x', 't', 32, 0,
  /* 303 */ 'l', 'd', '8', 'u', 32, 0,
  /* 309 */ 'b', 'a', 'u', 32, 0,
  /* 314 */ 'b', 'u', 32, 0,
  /* 318 */ 'm', 'a', 'c', 'c', 'u', 32, 0,
  /* 325 */ 'r', 'e', 'm', 'u', 32, 0,
  /* 331 */ 'b', 'r', 'u', 32, 0,
  /* 336 */ 'l', 's', 'u', 32, 0,
  /* 341 */ 'd', 'i', 'v', 'u', 32, 0,
  /* 347 */ 'b', 'y', 't', 'e', 'r', 'e', 'v', 32, 0,
  /* 356 */ 'b', 'i', 't', 'r', 'e', 'v', 32, 0,
  /* 364 */ 'l', 'd', 'i', 'v', 32, 0,
  /* 370 */ 'l', 'd', 'a', 'w', 32, 0,
  /* 376 */ 'l', 'd', 'w', 32, 0,
  /* 381 */ 's', 't', 'w', 32, 0,
  /* 386 */ 'c', 'l', 'z', 32, 0,
  /* 391 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 398 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 408 */ 'l', 'd', 'a', 'w', 32, 'r', '1', '1', ',', 32, 'c', 'p', '[', 0,
  /* 422 */ 'm', 's', 'y', 'n', 'c', 32, 'r', 'e', 's', '[', 0,
  /* 433 */ 's', 'e', 't', 'p', 's', 'c', 32, 'r', 'e', 's', '[', 0,
  /* 445 */ 's', 'e', 't', 'c', 32, 'r', 'e', 's', '[', 0,
  /* 455 */ 's', 'e', 't', 'd', 32, 'r', 'e', 's', '[', 0,
  /* 465 */ 's', 'e', 't', 'c', 'l', 'k', 32, 'r', 'e', 's', '[', 0,
  /* 477 */ 'm', 'j', 'o', 'i', 'n', 32, 'r', 'e', 's', '[', 0,
  /* 488 */ 's', 'y', 'n', 'c', 'r', 32, 'r', 'e', 's', '[', 0,
  /* 499 */ 'f', 'r', 'e', 'e', 'r', 32, 'r', 'e', 's', '[', 0,
  /* 510 */ 'o', 'u', 't', 's', 'h', 'r', 32, 'r', 'e', 's', '[', 0,
  /* 522 */ 'c', 'h', 'k', 'c', 't', 32, 'r', 'e', 's', '[', 0,
  /* 533 */ 'o', 'u', 't', 'c', 't', 32, 'r', 'e', 's', '[', 0,
  /* 544 */ 's', 'e', 't', 'p', 't', 32, 'r', 'e', 's', '[', 0,
  /* 555 */ 'o', 'u', 't', 't', 32, 'r', 'e', 's', '[', 0,
  /* 565 */ 'o', 'u', 't', 32, 'r', 'e', 's', '[', 0,
  /* 574 */ 'e', 'e', 'u', 32, 'r', 'e', 's', '[', 0,
  /* 583 */ 's', 'e', 't', 'e', 'v', 32, 'r', 'e', 's', '[', 0,
  /* 594 */ 's', 'e', 't', 'v', 32, 'r', 'e', 's', '[', 0,
  /* 604 */ 's', 'e', 't', 't', 'w', 32, 'r', 'e', 's', '[', 0,
  /* 615 */ 's', 'e', 't', 'r', 'd', 'y', 32, 'r', 'e', 's', '[', 0,
  /* 627 */ 's', 'e', 't', 32, 'p', 's', '[', 0,
  /* 635 */ 'i', 'n', 'i', 't', 32, 't', '[', 0,
  /* 643 */ 's', 's', 'y', 'n', 'c', 0,
  /* 649 */ 'g', 'e', 't', 32, 'r', '1', '1', ',', 32, 'e', 'd', 0,
  /* 661 */ 'g', 'e', 't', 32, 'r', '1', '1', ',', 32, 'i', 'd', 0,
  /* 673 */ 'c', 'l', 'r', 'e', 0,
  /* 678 */ 'g', 'e', 't', 32, 'r', '1', '1', ',', 32, 'e', 't', 0,
  /* 690 */ 'w', 'a', 'i', 't', 'e', 'u', 0,
  };

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, CLRE_0R, GETED_0R, GETET_0R, GETID_0R, SSYNC_0r, WA...
    return;
    break;
  case 1:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BAU_1r, BIT...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LDAWFI, LDWFI, SELECT_CC, STWFI
    PrintSpecial(MI, O, "comment"); 
    break;
  case 3:
    // BR_JT, BR_JT32, OUTSHR_2r
    printOperand(MI, 1, O); 
    break;
  case 4:
    // LDAWCP_lu6, LDAWCP_u6
    printMemOperand(MI, 0, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 1 encoded into 5 bits for 22 unique commands.
  switch ((Bits >> 24) & 31) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r,...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN
    O << " ADJCALLSTACKDOWN "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << " ADJCALLSTACKUP "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // BAU_1r, BLA_1r, BL_lu10, BL_u10, BRBU_lu6, BRBU_u6, BRFU_lu6, BRFU_u6,...
    return;
    break;
  case 4:
    // BR_JT, BR_JT32
    O << "\n"; 
    break;
  case 5:
    // CHKCT_2r, CHKCT_rus, OUTCT_2r, OUTCT_rus, OUTSHR_2r, OUTT_2r, OUT_2r, ...
    O << "], "; 
    break;
  case 6:
    // EEU_1r, FREER_1r, MJOIN_1r, MSYNC_1r, SYNCR_1r
    O << ']'; 
    return;
    break;
  case 7:
    // ENDIN_l2r, GETST_2r, GETTS_2r, INCT_2r, INSHR_2r, INT_2r, IN_2r, PEEK_...
    O << ", res["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 8:
    // GETPS_l2r
    O << ", ps["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 9:
    // INITCP_2r
    O << "]:cp, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 10:
    // INITDP_2r
    O << "]:dp, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 11:
    // INITLR_l2r
    O << "]:lr, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 12:
    // INITPC_2r
    O << "]:pc, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 13:
    // INITSP_2r
    O << "]:sp, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 14:
    // LDAWDP_lru6, LDAWDP_ru6, LDWDP_lru6, LDWDP_ru6, STWDP_lru6, STWDP_ru6
    O << ", dp["; 
    printMemOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 15:
    // LDAWFI
    O << " LDAWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 16:
    // LDAWSP_lru6, LDAWSP_lru6_RRegs, LDAWSP_ru6, LDAWSP_ru6_RRegs, LDWSP_lr...
    O << ", sp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 17:
    // LDWCP_lru6, LDWCP_ru6
    O << ", cp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 18:
    // LDWFI
    O << " LDWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 19:
    // SELECT_CC
    O << " SELECT_CC PSEUDO!"; 
    return;
    break;
  case 20:
    // SETEV_1r, SETV_1r
    O << "], r11"; 
    return;
    break;
  case 21:
    // STWFI
    O << " STWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 22) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r, BRBF_lru6,...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // ANDNOT_2r, CRC_l3r, OUTSHR_2r, SEXT_2r, SEXT_rus, ZEXT_2r, ZEXT_rus
    printOperand(MI, 2, O); 
    break;
  case 2:
    // BR_JT
    printInlineJT(MI, 0, O); 
    return;
    break;
  case 3:
    // BR_JT32
    printInlineJT32(MI, 0, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 20) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, CRC8_l4r, CRC_l3r, DIV...
    O << ", "; 
    break;
  case 1:
    // ANDNOT_2r, BITREV_l2r, BRBF_lru6, BRBF_ru6, BRBT_lru6, BRBT_ru6, BRFF_...
    return;
    break;
  case 2:
    // LD16S_3r, LD8U_3r, LDA16F_l3r, LDAWF_l2rus, LDAWF_l3r, LDW_2rus, LDW_3...
    O << '['; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  case 3:
    // LDA16B_l3r, LDAWB_l2rus, LDAWB_l3r
    O << "[-"; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 4 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 18) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    printOperand(MI, 2, O); 
    break;
  case 1:
    // CRC8_l4r, CRC_l3r
    printOperand(MI, 3, O); 
    break;
  case 2:
    // MACCS_l4r, MACCU_l4r
    printOperand(MI, 4, O); 
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
    break;
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 17) & 1) {
    // CRC8_l4r, LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r
    O << ", "; 
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, CRC_l3r, DIVS_l3r, DIV...
    return;
  }


  // Fragment 6 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 16) & 1) {
    // LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r
    printOperand(MI, 3, O); 
    O << ", "; 
    printOperand(MI, 4, O); 
  } else {
    // CRC8_l4r
    printOperand(MI, 4, O); 
    return;
  }


  // Fragment 7 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 15) & 1) {
    // LMUL_l6r
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
  } else {
    // LADD_l5r, LDIV_l5r, LSUB_l5r
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *XCoreAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 17 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '1', '0', 0,
  /* 4 */ 'r', '0', 0,
  /* 7 */ 'r', '1', '1', 0,
  /* 11 */ 'r', '1', 0,
  /* 14 */ 'r', '2', 0,
  /* 17 */ 'r', '3', 0,
  /* 20 */ 'r', '4', 0,
  /* 23 */ 'r', '5', 0,
  /* 26 */ 'r', '6', 0,
  /* 29 */ 'r', '7', 0,
  /* 32 */ 'r', '8', 0,
  /* 35 */ 'r', '9', 0,
  /* 38 */ 'c', 'p', 0,
  /* 41 */ 'd', 'p', 0,
  /* 44 */ 's', 'p', 0,
  /* 47 */ 'l', 'r', 0,
  };

  static const unsigned RegAsmOffset[] = {
    38, 41, 47, 4, 11, 14, 17, 20, 23, 26, 29, 32, 35, 0, 
    7, 44, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}
